
Immediate
================
- Fix floating point issue...

- Write body2ECI in MATLAB. Called at each timestep of forward pass (maybe inside step function), uses current attitude -> one line
- Change Satellite_Step() to include earth magnetic field (passed in as param)
- Add argument for B vector to milqr() function

Add magnetorquer control / magnetic field model (Change Jacobian in satelite_step function)
	Should pre-compute orbit and magnetic field in ECI or ECEF
	Pass in time series of B vectors to iLQR
	Convert the B vector to Body frame for calculating torque at each step


- Write controllability grammian solver in python (needs SGP4)

- Write script to test all the above together. 


- !!! Try to run MILQR in circuitpython !!!


// Pass parameters
==================
- Inertia and it's inverse
- Solver Options (including timestep)
- Magnetic field trajectory (pass in time sequence of B vectors) calls IGRF & sgp4
- Cost function matrices (Maybe?)

- Add functionality for different length trajectories (just pass N as parameter)


 Python
 ===================

-Call controllability algorithm {
	loop:
		until controllabiltiy found or max time surpassed
		-Call SGP4 (starting a few minutes in the future) to find a future satellite state (in ECI)
		-Call IGRF to get the Earth magnetic field (B vector) in ECEF for that state.
		-Convert the B vector to ECI
		-Add new B vector to the controllability grammian
		-Check for controllability
		-Add the B-vector to an array
	}

-If failed ??
-If succeeded:
	-Call MILQR with the B-vector array
		-Add check after solver runs that final attitude and velocity are within an acceptable tolerance (can do in MATLAB)

-If MILQR succeeds, wait until start time
-Call main control loop
	-Measure
	-Interpolate controls based on state measurement
	-Actuate


Misc
====================
- Linker script (with stack size): /home/nick/Documents/AA236/circuitpython/ports/atmel-samd/asf4/samd51/gcc/gcc
	> Default: 0xC000 = 44 KB (1000 = 4 KB, C-1 = 11, 11*4 = 44 KB)



















