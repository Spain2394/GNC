
Immediate
================
- Autocode is using QR to check rank at one stage. (might need to replace back slash with self written cholesky solver)

- Check floats/singles work okay (instead of doubles) -> ensure all numbers are in floating point range
- Try to remove large constants from Autocoded code -> force single precision

- !!! Try to run MILQR in circuitpython !!!

- Check variable sized arrays (needs C99 compiler)
- Linker script (with stack size): /home/nick/Documents/AA236/circuitpython/ports/atmel-samd/asf4/samd51/gcc/gcc
	> Default: 0xC000 = 44 KB (1000 = 4 KB, C-1 = 11, 11*4 = 44 KB)

// Pass parameters
==================
- Inertia and it's inverse
- Solver Options (including timestep)
- Magnetic field trajectory (pass in time sequence of B vectors) calls IGRF & sgp4
- Cost function matrices (Maybe?)


Add magnetorquer control / magnetic field model (Change Jacobian in satelite_step function)
	Should pre-compute orbit and magnetic field in ECI or ECEF
	Pass in time series of B vectors to iLQR
	Convert the B vector to Body frame for calculating torque at each step
	
Add functionality for different length trajectories (just pass N as parameter)


 Python
 ===================
-Add check after solver runs that final attitude and velocity are within an acceptable tolerance of
	the desired values. If not don't run the control sequence.
-Call to SGP4 to find a time series of future satellite states
-Call to IGRF and ECEF2Body -> create a time series of B vectors (in body frame)
-Call MILQR
-Main control loop
	- Interpolate controls based on state measurement



















